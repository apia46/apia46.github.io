// "instance" refers to the js object version of the thing
// "element" refers to the html element version of the thing
// sometimes they are implied though and it kind of sucks
// if implied it should be the instance

// "node"s are the draggable thingies in the graph
// "item"s are the item display thingies you can hover over in the graph. they are the indivisible units of the calculation or whatever
// sometimes "item" also means like, the data of items, but that should just be in dataset loading code
// in other places that is referred to by "contentId" and known as "itemData"
// same thing with "recipe" and "recipeData"

let parsedJson;

let data = {items:{}, recipes:[], machines: {}};

let previousMouseX;
let previousMouseY;

/*
let draggingConnection = false;
let dragConnectionElement;
let draggingLine;
let updateLineFunction;
*/

let previousRecipeSearchQuery = "";
let searchResults = [];
let searchScroll = 0;
let previousScrollDeltaY;
let previousRowsScrolled = 0;
let previousElementsWide;
let previousSearchMode;

let animFrame = 0;

let mouseX = 0;
let mouseY = 0;

function drag(element, accountForScaling, property="--pos", returnRelative) {
    var multiplier = (accountForScaling ? 1/Number(wrapper.style.getPropertyValue("--scale")||1) : 1);
    const changeX = (mouseX - previousMouseX) * multiplier;
    const changeY = (mouseY - previousMouseY) * multiplier;
    const posX = (Number(element.style.getPropertyValue(`${property}X`))||0) + changeX;
    const posY = (Number(element.style.getPropertyValue(`${property}Y`))||0) + changeY;
    element.style.setProperty(`${property}X`, posX);
    element.style.setProperty(`${property}Y`, posY);
    previousMouseX = mouseX;
    previousMouseY = mouseY;
    if (returnRelative) return [changeX, changeY];
    else return [posX, posY];
}

function loadDataset(dataset) {
    infoText.textContent = "Loading dataset";
    fetch(`assets/${dataset}/data.json`).then(response=>response.json())
        .then(parsed=>{
            parsedJson = parsed;
            switch (parsed.metadata.dataStructure) {
                case "normal":
                    Object.assign(data.items, parsed.items);
                    data.recipes.push(...parsed.recipes);
                    Object.assign(data.machines, parsed.machines);
                break;
                case "recexM": // extra-minified

                    function addItem(item, unit) {
                        var itemId = (item.i||item.N).replace("GT$", "gregtech:") + (item.m||item.m===0?"#"+item.m:"");
                        if (!data.items[itemId]) {
                            var itemData = { name: item.N||itemId }
                            if (unit) itemData.unit = unit;
                            switch (parsed.metadata.imageAutogenerateData) { // for now. later the cfg will be worked into it but i dont wanna do js text parsing right now
                                case "gtnh": gtnhGetImageData(itemId, itemData); break;
                            }
                            data.items[itemId] = itemData;
                            /*if (itemData.image) {
                                const img = new Image();
                                img.onload = ()=>{if (img.naturalHeight > 16) animatedImages.push(itemData.image)};
                                img.src = itemData.image;
                            }*/
                        }
                        return [itemId, item.a];
                    }

                    parsed.sources.find(source=>source.type=="gregtech")?.machines.forEach(machine=>{
                        data.machines[machine.n] = {
                            name: machine.n,
                            image: `assets/${dataset}/images/machines/${machine.n}.png`,
                            speed: 1
                        }
                        machine.r.forEach(recipe=>{
                            if (!recipe.E) return;
                            data.recipes.push({
                                time: recipe.t/20,
                                machines: [machine.n],
                                inputs: [...recipe["1"].map(item=>addItem(item)), ...recipe["3"].map(item=>addItem(item, "L"))],
                                outputs: [...recipe["2"].map(item=>addItem(item)), ...recipe["4"].map(item=>addItem(item, "L"))]
                            });
                        });
                    });
                break;
            }
            console.log("loaded!");
            infoText.textContent = "";
            previousSearchMode = ""; // really jank. fix this please
        }
    );
}

function load() {
    document.addEventListener("mousemove", event=>{
        mouseX = event.clientX;
        mouseY = event.clientY;
    });

    var dragGraph = ()=>{drag(wrapper)};
    wrapper.addEventListener("mousedown", ()=>{previousMouseX = mouseX; previousMouseY = mouseY; wrapper.addEventListener("mousemove", dragGraph)});
    wrapper.addEventListener("mouseup", ()=>{wrapper.removeEventListener("mousemove", dragGraph)});
    wrapper.addEventListener("mouseleave", ()=>{wrapper.removeEventListener("mousemove", dragGraph)});
    wrapper.addEventListener("wheel", event=>{
        var scaleFactor = 2**(-event.deltaY*0.003);
        wrapper.style.setProperty("--scale", Number(wrapper.style.getPropertyValue("--scale")||1) * scaleFactor);
        var posX = Number(wrapper.style.getPropertyValue("--posX"))||0;
        var posY = Number(wrapper.style.getPropertyValue("--posY"))||0;
        wrapper.style.setProperty("--posX", posX + (1 - scaleFactor) * (mouseX - posX));
        wrapper.style.setProperty("--posY", posY + (1 - scaleFactor) * (mouseY - posY));
    });
   
    setInterval(()=>{
        var element = document.elementFromPoint(mouseX, mouseY);
        hover.style.setProperty("--posX", mouseX);
        hover.style.setProperty("--posY", mouseY);
        if (!element) {
            hover.classList.remove("show");
        } else if (element.nodeName == "ITEM") {
            hover.innerHTML = element.getAttribute("name");
            if (element.getAttribute("accurateQuantity")) hover.innerHTML += `<br>${element.getAttribute("accurateQuantity")}`;
            hover.classList.add("show");
        } else if (element.nodeName == "MACHINE") {
            hover.innerHTML = element.getAttribute("name");
            if (element.getAttribute("accurateAmount")) hover.innerHTML += `<br>${element.getAttribute("accurateAmount")}`;
            hover.classList.add("show");
        } else if (text = element.getAttribute("name")) {
            hover.innerHTML = text;
            hover.classList.add("show");
        } else hover.classList.remove("show");
    }, 0);

    searchOverlay.addEventListener("wheel", event=>{
        searchScroll += event.deltaY * 0.5;
        previousScrollDeltaY = event.deltaY * 0.5;
        if (previousRowsScrolled == 0 && searchScroll < 0) searchScroll = 0;
        switch (document.body.getAttribute("state")) {
            case "itemSearch": displaySearchedItems(); return;
            case "recipeSearch": displaySearchedRecipes(); return;
        }
    });
}


// https://www.quirksmode.org/js/findpos.html
function getGraphPositionFromCenter(element) {
    var posX = element.offsetWidth / 2;
    var posY = element.offsetHeight / 2;
    do {
        posX += element.offsetLeft;
        posY += element.offsetTop;
    } while ((element = element.offsetParent) != graph);
    return [posX, posY];
}

function updateLine(lineOrConnection, from, to) {
    if (!lineOrConnection.nodeName) {
        from = getGraphPositionFromCenter(lineOrConnection.inputs.element);
        to = getGraphPositionFromCenter(lineOrConnection.outputs.element);
        lineOrConnection = lineOrConnection.line;
    }
    var aPos = from;
    var bPos = to;
    lineOrConnection.style.setProperty("--aX", aPos[0]);
    lineOrConnection.style.setProperty("--aY", aPos[1]);
    lineOrConnection.style.setProperty("--bX", bPos[0]);
    lineOrConnection.style.setProperty("--bY", bPos[1]);
}

function oppositeType(type) { return type == "outputs" ? "inputs" : "outputs" }

function searchItems() {
    searchScroll = 0;
    var query = itemSearchBar.value.toLowerCase();
    searchResults = Object.keys(data.items).filter(item=>data.items[item].name.toLowerCase().includes(query));
    if (searchResults.length < 4000) searchResults.sort((a,b)=>{
        return searchScore(data.items[b].name.toLowerCase(), query) - searchScore(data.items[a].name.toLowerCase(), query);
    });
    previousRecipeSearchQuery = "";
    previousSearchMode = "items";
    displaySearchedItems(true);
}

function searchRecipes() {
    searchScroll = 0;
    previousRowsScrolled = 0;
    var queries = recipeSearchBar.value.toLowerCase().split(",").map(query=>query.trim());

    var inputQueries = []
    var outputQueries = []
    var eitherQueries = []
    for (let query of queries) {
        if (query.slice(0,2) == "i:") inputQueries.push(query.slice(2));
        else if (query.slice(0,2) == "o:") outputQueries.push(query.slice(2));
        else eitherQueries.push(query);
    }
    var toSearchFrom;
    if (previousSearchMode == "recipes" && recipeSearchBar.value.includes(previousRecipeSearchQuery)) toSearchFrom = searchResults;
    else toSearchFrom = Object.keys(data.recipes);
    searchResults = toSearchFrom.filter(recipe=>{
        var recipeData = data.recipes[recipe];
        var inputs = recipeData.inputs.map(input=>data.items[input[0]].name.toLowerCase());
        var outputs = recipeData.outputs.map(output=>data.items[output[0]].name.toLowerCase());
        var eithers = [...inputs, ...outputs];
        return eitherQueries.every(thisQuery=>eithers.some(name=>name.includes(thisQuery)))
            && inputQueries.every(thisQuery=>inputs.some(name=>name.includes(thisQuery)))
            && outputQueries.every(thisQuery=>outputs.some(name=>name.includes(thisQuery)));
    });
    // sort recipes
    previousRecipeSearchQuery = recipeSearchBar.value;
    previousSearchMode = "recipes";
    displaySearchedRecipes(true);
}

function searchScore(target, query) {
    var score = 0;
    var index = target.indexOf(query);
    score -= index;
    score -= [0, ...target.split("")].reduce((total, thisLetter, index)=>{
        return total + "abcdefghijklmnopqrstuvwxyz".indexOf(thisLetter) * 26**-index;
    })
    return score;
}

function displaySearchedItems(searchUpdated) {
    var scale = Number(wrapper.style.getPropertyValue("--scale")||1);
    searchOverlay.style.setProperty("--scale", scale);
    var elementsWide = Math.floor((searchOverlay.offsetWidth - 16) / (96*scale+16));
    var elementsTall = Math.ceil((searchOverlay.offsetHeight - 16) / (96*scale+16));
    var rowsScrolled = Math.floor(searchScroll / scale / 112);
    searchOverlay.style.setProperty("--scroll-offset", searchScroll % (112 * scale));
    var elementsTotal = elementsTall * elementsWide;
    if (searchUpdated || rowsScrolled != previousRowsScrolled) {
        searchOverlay.innerHTML = "";
        searchResults.slice(rowsScrolled*elementsWide, elementsTotal + (rowsScrolled+1)*elementsWide).forEach(itemId=>{
            var itemContainer = document.createElement("node");
            itemContainer.classList.add("itemNode");
            itemContainer.addEventListener("mousedown", ()=>resolveSearchItem(itemContainer));
            itemContainer.setAttribute("itemId", itemId);
            itemContainer.appendChild(new Item(itemId, null, null, null, null, true).element);
            searchOverlay.appendChild(itemContainer);
        });
    }
    previousRowsScrolled = rowsScrolled;
}

function displaySearchedRecipes(searchUpdated) {
    var scale = Number(wrapper.style.getPropertyValue("--scale")||1);
    searchOverlay.style.setProperty("--scale", scale);
    var elementsWide = Math.floor((searchOverlay.offsetWidth - 16) / (300*scale+16));
    var elementsTall = Math.ceil((searchOverlay.offsetHeight - 16) / (160*scale+16));
    var rowsScrolled = previousRowsScrolled;
    if (previousElementsWide && elementsWide != previousElementsWide) {
        rowsScrolled = Math.floor(rowsScrolled * previousElementsWide / elementsWide);
        var addUpScroll = false;
    }
    if (searchOverlay.childElementCount) {
        var bottomOfFirstRow = Array.from(searchOverlay.children).slice(0,elementsWide).map(element=>element.offsetTop+element.offsetHeight).reduce((total, bottom)=>Math.max(total,bottom));
        if (bottomOfFirstRow < 0) {
            searchScroll = previousScrollDeltaY - bottomOfFirstRow;
            rowsScrolled++;
        }
        if (searchScroll < 0) {
            addUpScroll = true;
            rowsScrolled--;
        }
    }
    var elementsTotal = elementsTall * elementsWide;
    if (searchUpdated || rowsScrolled != previousRowsScrolled) {
        searchOverlay.innerHTML = "";
        searchResults.slice(rowsScrolled*elementsWide, elementsTotal + (rowsScrolled+1)*elementsWide).forEach(recipeId=>{
            var node = new RecipeNode(0, 0, recipeId, true);
            node.element.addEventListener("mousedown", ()=>resolveSearchRecipe(node.element));
            node.displayBaseCase();
            searchOverlay.appendChild(node.element);
        });
    }
    if (addUpScroll) {
        var rowsAccountedFor = 0;
        var amountToAdd = 0;
        do {
            amountToAdd += Array.from(searchOverlay.children).slice(elementsWide*rowsAccountedFor,elementsWide*(rowsAccountedFor+1)).map(element=>element.offsetHeight+8).reduce((total, height)=>Math.max(total,height)) + 56*scale;
            rowsAccountedFor++;
        } while (amountToAdd < -previousScrollDeltaY);
        searchScroll += amountToAdd;
    }
    searchOverlay.style.setProperty("--scroll-offset", searchScroll);
    previousElementsWide = elementsWide;
    previousRowsScrolled = rowsScrolled;
}

function resolveSearchItem(element) {
    const itemId = element.getAttribute("itemId");
    const graphScale = Number(wrapper.style.getPropertyValue('--scale')||1);
    const nodeInstance = new ItemNode( 
        (element.offsetLeft - (Number(wrapper.style.getPropertyValue('--posX'))||0)) / graphScale,
        (element.offsetTop - (Number(wrapper.style.getPropertyValue('--posY'))||0)) / graphScale,
        itemId
    );
    nodeInstance.attachToGraph();
    previousMouseX = mouseX;
    previousMouseY = mouseY;
    wrapper.addEventListener("mousemove", nodeInstance.dragFunction);
}

function resolveSearchRecipe(element) {
    const recipeId = element.getAttribute("recipeId");
    const graphScale = Number(wrapper.style.getPropertyValue('--scale')||1);
    const nodeInstance = new RecipeNode( 
        (element.offsetLeft - (Number(wrapper.style.getPropertyValue('--posX'))||0)) / graphScale,
        (element.offsetTop - (Number(wrapper.style.getPropertyValue('--posY'))||0)) / graphScale,
        recipeId,
    );
    nodeInstance.attachToGraph();
    previousMouseX = mouseX;
    previousMouseY = mouseY;
    wrapper.addEventListener("mousemove", nodeInstance.dragFunction);
}

function formatNumber(number, morePrecise) {
    if (morePrecise) return number.toPrecision(8);
    return number.toPrecision(4);
}