let parsedJson;

let data = {items:{}, recipes:{}, machines: {}};
let nodeIdIter = 0;
let itemIdIter = 0;

let previousMouseX;
let previousMouseY;

let nodes = {};

let draggingConnection = false;
let dragConnectionElement;
let draggingLine;
let updateLineFunction;

var searchResults = [];
var searchScroll = 0;
var rowsScrolledPrevious = 0;

function drag(event, element, accountForScaling) {
    var multiplier = (accountForScaling ? 1/Number(graph.style.getPropertyValue("--scale")||1) : 1);
    element.style.setProperty("--posX", Number(element.style.getPropertyValue("--posX")||0) + (event.clientX - previousMouseX) * multiplier)
    element.style.setProperty("--posY", Number(element.style.getPropertyValue("--posY")||0) + (event.clientY - previousMouseY) * multiplier)
    previousMouseX = event.clientX;
    previousMouseY = event.clientY;
    if (element.nodeName == "NODE") allItemsInNode(element).forEach(item=>{if (item.connection) updateLine(item.connection)});
}

function loadDataset(dataset) {
    infoText.textContent = "Loading dataset";
    fetch(`assets/${dataset}/data.json`).then(response=>response.json())
        .then(parsed=>{
            parsedJson = parsed;
            switch (parsed.metadata.dataStructure) {
                case "normal":
                    data = parsed;
                break;
                case "recexM": // extra-minified
                    data = {
                        metadata: parsed.metadata,
                        items: {},
                        recipes: [],
                        machines: {}
                    }

                    function addItem(item, unit) {
                        var itemId = (item.i||item.N).replace("GT$", "gregtech:") + (item.m||item.m===0?"#"+item.m:"");
                        if (!data.items[itemId]) {
                            var itemData = { name: item.N||itemId }
                            switch (parsed.metadata.imageAutogenerateData) { // for now. later the cfg will be worked into it but i dont wanna do js text parsing right now
                                case "gtnh": gtnhGetImageData(itemId, itemData); break;
                            }
                            if (unit) itemData.unit = unit
                            data.items[itemId] = itemData
                        }
                        return [itemId, item.a];
                    }

                    parsed.sources.find(source=>source.type=="gregtech")?.machines.forEach(machine=>{
                        data.machines[machine.n] = {
                            name: machine.n,
                            image: `assets/${dataset}/images/machines/${machine.n}.png`,
                            speed: 1
                        }
                        machine.r.forEach(recipe=>{
                            if (!recipe.E) return;
                            data.recipes.push({
                                time: recipe.t/20,
                                machines: [machine.n],
                                inputs: [...recipe["1"].map(addItem), ...recipe["3"].map(addItem, "L")],
                                outputs: [...recipe["2"].map(addItem), ...recipe["4"].map(addItem, "L")]
                            });
                        });
                    });
                break;
            }
            console.log("loaded!");
            infoText.textContent = "";
        }
    );
}

function load() {
    var dragGraph = event=>{drag(event, graph)};
    wrapper.addEventListener("mousedown", event=>{previousMouseX = event.clientX; previousMouseY = event.clientY; wrapper.addEventListener("mousemove", dragGraph)});
    wrapper.addEventListener("mouseup", ()=>{wrapper.removeEventListener("mousemove", dragGraph)});
    wrapper.addEventListener("mouseleave", ()=>{wrapper.removeEventListener("mousemove", dragGraph)});
    wrapper.addEventListener("wheel", event=>{
        var scaleFactor = 2**(-event.deltaY*0.003);
        graph.style.setProperty("--scale", Number(graph.style.getPropertyValue("--scale")||1) * scaleFactor);
        var posX = Number(graph.style.getPropertyValue("--posX")||0);
        var posY = Number(graph.style.getPropertyValue("--posY")||0);
        graph.style.setProperty("--posX", posX + (1 - scaleFactor) * (event.clientX - posX));
        graph.style.setProperty("--posY", posY + (1 - scaleFactor) * (event.clientY - posY));
    });

    ["mouseleave", "mouseup"].forEach(action=>wrapper.addEventListener(action, event=>{
        if (draggingConnection) {
            wrapper.removeEventListener("mousemove", updateLineFunction);
            draggingConnection = false;
            dragConnectionElement.classList.remove("connecting");
            var connectedToElement = document.elementFromPoint(event.clientX, event.clientY);
            if (connectedToElement.nodeName == "ITEM" && connectedToElement != dragConnectionElement && canConnect(
                    fromInstance = itemGetInstance(dragConnectionElement), 
                    toInstance = itemGetInstance(connectedToElement)
            )) {
                updateLine(draggingLine, getGraphPositionFromCenter(dragConnectionElement), getGraphPositionFromCenter(connectedToElement));
                var isFromInput = fromInstance.type == "inputs" || toInstance.type == "outputs";
                if (fromInstance.type == "node") fromInstance.effectiveType = isFromInput?"inputs":"outputs";
                if (toInstance.type == "node") toInstance.effectiveType = isFromInput?"outputs":"inputs";
                var connection = {
                    inputs: isFromInput?fromInstance:toInstance,
                    outputs: isFromInput?toInstance:fromInstance,
                    line: draggingLine
                }
                fromInstance.connection = connection;
                toInstance.connection = connection;
                draggingLine.addEventListener("click", ()=>{removeConnection(connection)})
            } else {
                draggingLine.remove();
            }
        }
    }));

    ["mousemove", "click"].forEach(action=>document.addEventListener(action, event=>{
        var element = document.elementFromPoint(event.clientX, event.clientY);
        var name = element.getAttribute("name");
        hover.textContent = name;
        hover.style.setProperty("--posX", event.clientX);
        hover.style.setProperty("--posY", event.clientY);
        if (name) hover.classList.add("show");
        else hover.classList.remove("show");
    }));

    searchOverlay.addEventListener("wheel", event=>{
        searchScroll += event.deltaY;
        searchScroll = Math.max(searchScroll, 0);
        switch (document.body.getAttribute("state")) {
            case "itemSearch": updateSearchDisplayItems(); return;
            case "recipeSearch": updateSearchDisplayRecipes(); return;
        }
    });
}

function newNode(generatorFunction, posX, posY, params) {
    var nodeElement = document.createElement("node");
    nodeElement.id = nodeIdIter;
    nodeElement.style.setProperty("--posX", posX);
    nodeElement.style.setProperty("--posY", posY);
    
    var dragNode = event=>{drag(event, nodeElement, true)};
    nodeElement.addEventListener("mousedown", event=>{event.stopPropagation(); previousMouseX = event.clientX; previousMouseY = event.clientY; wrapper.addEventListener("mousemove", dragNode)});
    wrapper.addEventListener("mouseup", ()=>{wrapper.removeEventListener("mousemove", dragNode)});
    wrapper.addEventListener("mouseleave", ()=>{wrapper.removeEventListener("mousemove", dragNode)});
    
    nodeElement.innerHTML += `<div class="delete" onclick="removeNode(${nodeIdIter})">X</div>`;
    
    var nodeInstance = generatorFunction(nodeElement, params);
    nodeElement.classList.add(nodeInstance.type);
    graph.appendChild(nodeElement);
    nodes[nodeInstance.id] = nodeInstance;
    nodeDisplayBaseCase(nodeInstance);
    return nodeInstance;
}

function removeNode(id) {
    document.getElementById(id).remove();
    delete nodes[id];
}

// node generators
function recipeNode(node, recipe) {
    var recipeData = data.recipes[recipe];
    var nodeInstance = {
        id: nodeIdIter++,
        type: "recipeNode",
        element: node,
        recipe: recipe,
        machine: { // properties of machine running the recipe
            machine: recipeData.machines[0], // type of machine
        }
    }
    var machineData = data.machines[nodeInstance.machine.machine];
    node.innerHTML += `
        <div class="machine" style="--image:url('${machineData.image}');"></div>
        <div class="inputs"></div>
        <div class="recipe-arrow"></div>
        <div class="outputs"></div>
    `;
    var inputs = recipeData.inputs.map((input, index) => {
        var item = generateItem(input[0], "inputs", index);
        node.querySelector(".inputs").appendChild(item);
        return {type:"inputs", index:index, item:input[0], baseQuantity:input[1], element:item, node:nodeInstance, id:itemIdIter++}
    });
    var outputs = recipeData.outputs.map((output, index) => {
        var item = generateItem(output[0], "outputs", index);
        node.querySelector(".outputs").appendChild(item);
        return {type:"outputs", index:index, item:output[0], baseQuantity:output[1], element:item, node:nodeInstance, id:itemIdIter++}
    });
    nodeInstance.inputs = inputs;
    nodeInstance.outputs = outputs;
    return nodeInstance;
}

function itemNode(node, item) {
    node.innerHTML += `
        <div class="number-container"><input type="numeric" placeholder="quantity"></input><span>${data.items[item].unit||""}</span></div>
        <button>SET</button>
    `
    var nodeInstance = {
        id: nodeIdIter++,
        type: "itemNode",
        element: node,
    }
    var itemElement = generateItem(item, "", "");
    nodeInstance.item = {type:"node", item:item, element:itemElement, node:nodeInstance, id:itemIdIter++};
    node.querySelector("button").addEventListener("click", ()=>{propagate(nodeInstance.item, Number(node.querySelector("input").value));});
    node.insertBefore(itemElement, node.firstChild);
    return nodeInstance;
}
// end node generators

function generateItem(item, type, index, functionless) {
    var itemData = data.items[item];
    var item = document.createElement("item");
    item.style.setProperty("--image", `url('${itemData.image}')`);
    if (itemData.imageModulation) item.style.setProperty("--imageModulation", itemData.imageModulation);
    if (itemData.imageOverlay) item.style.setProperty("--imageOverlay", `url('${itemData.imageOverlay}')`);
    if (!functionless) item.addEventListener("mousedown", event=>{event.stopPropagation(); startConnection(item);});
    item.setAttribute("name", itemData.name);
    item.setAttribute("type", type);
    item.setAttribute("index", index);
    return item;
}

function startConnection(element) {
    element.classList.add("connecting");
    draggingConnection = true;
    dragConnectionElement = element;
    draggingLine = document.createElement("line");
    graph.appendChild(draggingLine);

    var scale = Number(graph.style.getPropertyValue("--scale")||1);
    updateLineFunction = event=>{updateLine(draggingLine,
        getGraphPositionFromCenter(dragConnectionElement),
        [
            (event.clientX - wrapper.offsetLeft - Number(graph.style.getPropertyValue("--posX")||0)) / scale,
            (event.clientY - wrapper.offsetTop - Number(graph.style.getPropertyValue("--posY")||0)) / scale
        ]);
    }
    wrapper.addEventListener("mousemove", updateLineFunction);
    var dragStart = getGraphPositionFromCenter(dragConnectionElement);
    updateLineFunction({clientX:dragStart.x, clientY:dragStart.y});
}

// https://www.quirksmode.org/js/findpos.html
function getGraphPositionFromCenter(element) {
    var posX = element.offsetWidth / 2;
    var posY = element.offsetHeight / 2;
    do {
        posX += element.offsetLeft;
        posY += element.offsetTop;
    } while ((element = element.offsetParent) != graph);
    return [posX, posY];
}

function updateLine(lineOrConnection, from, to) {
    if (!lineOrConnection.nodeName) {
        from = getGraphPositionFromCenter(lineOrConnection.inputs.element);
        to = getGraphPositionFromCenter(lineOrConnection.outputs.element);
        lineOrConnection = lineOrConnection.line;
    }
    var aPos = from;
    var bPos = to;
    lineOrConnection.style.setProperty("--aX", aPos[0]);
    lineOrConnection.style.setProperty("--aY", aPos[1]);
    lineOrConnection.style.setProperty("--bX", bPos[0]);
    lineOrConnection.style.setProperty("--bY", bPos[1]);
}

function canConnect(fromInstance, toInstance) {
    if (fromInstance.item != toInstance.item) return false
    if (fromInstance.type == "inputs" && toInstance.type == "inputs") return false
    if (fromInstance.type == "outputs" && toInstance.type == "outputs") return false
    if (fromInstance.connection || toInstance.connection) return false
    return true
}

function itemGetInstance(element) {
    var nodeElement = element;
    while ((nodeElement = nodeElement.offsetParent).nodeName != "NODE");
    switch (nodes[nodeElement.id].type) {
        case "recipeNode": return nodes[nodeElement.id][element.getAttribute("type")][element.getAttribute("index")];
        case "itemNode": return nodes[nodeElement.id].item;
    }
}

function allItemsInNode(elementOrNode) {
    var node = elementOrNode.nodeName ? nodes[elementOrNode.id] : elementOrNode;
    switch (node.type) {
        case "recipeNode": return [...node.inputs, ...node.outputs];
        case "itemNode": return [node.item];
    }
}

function removeConnection(connection) {
    connection.line.remove();
    delete connection.inputs.connection;
    delete connection.outputs.connection;
}

function propagate(itemInstance, value, previous) {
    if (!value && value !== 0) {
        console.log("error in propagation", itemInstance);
        return;
    }
    itemInstance.quantity = value;
    var node = itemInstance.node;
    switch (node.type) {
        case "recipeNode":
            node.multiplier = itemInstance.quantity / itemInstance.baseQuantity;
            node.machine.amount = data.recipes[node.recipe].time * node.multiplier / data.machines[node.machine.machine].speed;
            allItemsInNode(node).forEach(item=>{
                if (item != itemInstance) {
                    item.quantity = item.baseQuantity * node.multiplier;
                    var connection = item.connection;
                    if (connection) {
                        propagate(connection[oppositeType(item.type)], item.quantity, item);
                    }
                }
            })
        break;
        case "itemNode":
            var connection = itemInstance.connection;
            if (connection && connection[oppositeType(itemInstance.effectiveType)] != previous) {
                propagate(connection[oppositeType(itemInstance.effectiveType)], value, itemInstance);
            }
            node.element.querySelector("input").value = itemInstance.quantity;
        break;
    }
    nodeDisplayMultipliedCase(node);
}

function oppositeType(type) { return type == "outputs" ? "inputs" : "outputs" }

function nodeDisplayBaseCase(node) {
    switch (node.type) {
        case "recipeNode":
            node.element.querySelector(".machine").setAttribute("amount", `${data.recipes[node.recipe].time}s`);
            allItemsInNode(node).forEach(item=>{
                item.element.setAttribute("quantity", `${item.baseQuantity}${data.items[item.item].unit||""}`);
            });
        break;
        case "itemNode": break;
    }
}

function nodeDisplayMultipliedCase(node) {
    switch (node.type) {
        case "recipeNode":
            node.element.querySelector(".machine").setAttribute("amount", "x" + node.machine.amount.toFixed(2));
            allItemsInNode(node).forEach(item=>{
                if (item.quantity || item.quantity === 0) item.element.setAttribute("quantity", `${item.quantity.toFixed(2)}${data.items[item.item].unit||""}`);
                else item.element.setAttribute("quantity", "");
            });
        break;
        case "itemNode": break;
    }
}

function testAllItems() {
    var index = 0;
    Object.keys(data.items).forEach(item=>{
        if (data.items[item].image) {
            newNode(itemNode, (index % 100) * 200, (index / 100) * 240, item);
            index += 1;
        }
    });
}

function searchItems() {
    searchScroll = 0;
    var query = itemSearchBar.value;
    searchResults = Object.keys(data.items).filter(item=>{
        return item.toLowerCase().includes(query.toLowerCase()) || data.items[item].name.toLowerCase().includes(query.toLowerCase());
    })
    updateSearchDisplayItems(true);
}


function updateSearchDisplayItems(searchUpdated) {
    var elementsWide = Math.floor((searchOverlay.offsetWidth - 16) / 176);
    var elementsTall = Math.ceil((searchOverlay.offsetHeight - 16) / 176);
    var rowsScrolled = Math.floor(searchScroll / 176);
    searchOverlay.style.setProperty("--scroll-offset", searchScroll % 176);
    var elementsTotal = elementsTall * elementsWide;
    if (searchUpdated || rowsScrolled != rowsScrolledPrevious) {
        searchOverlay.innerHTML = "";
        searchResults.slice(rowsScrolled*elementsWide, elementsTotal + (rowsScrolled+1)*elementsWide).forEach(item=>{
            var itemContainer = document.createElement("node");
            itemContainer.classList.add("itemNode");
            itemContainer.addEventListener("mousedown", ()=>resolveSearchItem(itemContainer));
            itemContainer.setAttribute("item", item);
            itemContainer.appendChild(generateItem(item, "", "", true));
            searchOverlay.appendChild(itemContainer);
        });
    }
    rowsScrolledPrevious = rowsScrolled;
}

function resolveSearchItem(element) {
    var item = element.getAttribute("item");
    var graphScale = Number(graph.style.getPropertyValue('--scale')||1)
    newNode(itemNode, 
        (element.offsetLeft - Number(graph.style.getPropertyValue('--posX')||0)) / graphScale,
        (element.offsetTop - Number(graph.style.getPropertyValue('--posY')||0)) / graphScale,
    item);
}